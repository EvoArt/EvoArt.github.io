[
  {
    "objectID": "socialevo/problems-2.html",
    "href": "socialevo/problems-2.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "+++ weave = true +++ @def title = ‚ÄúSocial evo probs 2‚Äù\ninsert_weave _assets/problems-2.jmd"
  },
  {
    "objectID": "otto_day/otto_day_p1.html",
    "href": "otto_day/otto_day_p1.html",
    "title": "Primer 1. Functions and Approximations",
    "section": "",
    "text": "There is a Julia package specifically for working with Taylor series, which is apparently fast for tricky tasks. I don‚Äôt feel like I have too much to add here, but I‚Äôll show the basic syntax of getting a Taylor series approximation of a function and plotting it, and signpost a nice video resource for getting a feeling the theory behing Taylor series.\n\nusing TaylorSeries, GLMakie\nO = 5\ng(x) = 2x - x^2 +x^3 +cos(x)\ng_approx = taylor_expand(g, 0, order=O)\n\n 1.0 + 2.0 t - 1.5 t¬≤ + 1.0 t¬≥ + 0.041666666666666664 t‚Å¥ + ùí™(t‚Å∂)\n\n\nIn Makie, we can plot a function of a single variable over a given interval as a line plot, by calling plot(interval,function).\n\nplot(-8..8,g)\n\n\n\n\nUnfortunately, we cant do plot(-8..8,g_approx) since g_approx is not a function (although it is callable confusingly enough). So if we want to use the plot(interval,function) syntax we can either create a function e.g.¬†f(x) = g_approx(x), or we can just use an anonymous function like so.\nplot!(-8..8,x -&gt; g_approx(x))\n\n\n\n\n\nFor a great video to get some intuition about how/why Taylor series approximations work, see the from Grant Sanderson.\n\nThis inspired me to try my own Taylor series animation.\n\nusing GLMakie\ntime = Observable(0.0)\nO = Observable(0)\n\nxs = range(-8, 8, length=80)\n\nys_1 = g.(xs)\nprev = @lift(taylor_expand(g, 0, order=$O).(xs))\ntarget = @lift(taylor_expand(g, 0, order=$O+1).(xs))\nys_2 = @lift($prev + ( $target - $prev) * $time)\n\nfig = lines(xs, ys_1, color = :blue, linewidth = 4,\n    axis = (title = @lift(\"O = $($O)\"),))\nlines!(xs, ys_2, color = :red, markersize = 15)\n\nframerate = 30\ntimestamps = range(0, 8, step=1/framerate)\n#=\nrecord(fig, \"./docs/otto_day/taylor_animation.mp4\", timestamps;\n        framerate = framerate) do t\n    O[] = Int(floor(t))\n    time[] = t -floor(t)\nend\n=#\npwd()\n\n\"C:\\\\Users\\\\arn203\\\\OneDrive - University of Exeter\\\\Documents\\\\Pages\\\\manual\\\\otto_day\"\n\n\n\nHmmm, needs some work. Perhaps I‚Äôll circle back round to this."
  },
  {
    "objectID": "otto_day/otto_day_03.html",
    "href": "otto_day/otto_day_03.html",
    "title": "3. Deriving Classical Models",
    "section": "",
    "text": "This chapter was mostly about applying techniques from the previous chapter to derive and to understand important ecological and evolutionary models. That said, one important tool that is introduced is the mating table. Here we will run through a short example of how to produce a mating table programmatically, using symbolic computing. Then we‚Äôll get the governing equations of our system from the mating table and visualise the results for a specific set of parameter values.\nFirst we declare the variables we will use and create two Dicts, one linking allele type to allele frequency, and the other linking genotype to fitness function.\n\nusing DataFrames, Latexify, Symbolics, LaTeXStrings, CairoMakie\n@variables p q W·¥¨·¥¨ W·¥¨·µÉ W·µÉ·µÉ WÃÑ \nfreq = Dict(\"A\" =&gt; p, \"a\" =&gt; q)\nW =  Dict(\"AA\" =&gt; W·¥¨·¥¨, \"Aa\" =&gt; W·¥¨·µÉ, \"aA\" =&gt; W·¥¨·µÉ, \"aa\" =&gt; W·µÉ·µÉ)\n\nDict{String, Num} with 4 entries:\n  \"AA\" =&gt; W·¥¨·¥¨\n  \"Aa\" =&gt; W·¥¨·µÉ\n  \"aa\" =&gt; W·µÉ·µÉ\n  \"aA\" =&gt; W·¥¨·µÉ\n\n\nNext we need to create vectors of values that we will use to populate the mating table. self and other are just String representations of the different alleles.\n\nself = [\"A\",\"A\",\"a\",\"a\"]\nother = [\"A\",\"a\",\"A\",\"a\"]\nuniting =  self .* \" √ó \" .* other\n\n4-element Vector{String}:\n \"A √ó A\"\n \"A √ó a\"\n \"a √ó A\"\n \"a √ó a\"\n\n\nFor the next columns we will use vector comprehensions to build vectors of expressions by multiplying symbolic variables, which we look up in the Dicts we made before.\n\nfreq_before = [freq[self[i]] * freq[other[i]] for i in 1:4]\nfreq_weighted = freq_before .* [W[self[i]*other[i]] for i in 1:4]\nfreq_after = freq_before .* [W[self[i]*other[i]]/WÃÑ for i in 1:4]\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{c}\n\\frac{p^{2} W^{A A}}{\\textnormal{\\={W}}} \\\\\n\\frac{W^{A a} p q}{\\textnormal{\\={W}}} \\\\\n\\frac{W^{A a} p q}{\\textnormal{\\={W}}} \\\\\n\\frac{q^{2} W^{a a}}{\\textnormal{\\={W}}} \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nThen, we can get the proportions of each allele produced by summing the number of occurrences of ‚ÄúA‚Äù.\n\nA = [sum([self[i],other[i]] .==\"A\") for i in 1:4] .//2\na = 1 .- A\n\n4-element Vector{Rational{Int64}}:\n 0//1\n 1//2\n 1//2\n 1//1\n\n\nLastly, we combine and name our columns in a DataFrame. We only need to convert uniting to LaTeXStrings because otherwise when we latexify matingTable, an attempt is made to actually multiply self by other.\n\nmatingTable = DataFrame([LaTeXString.(uniting),freq_before,freq_weighted,freq_after,A,a],\n                        [\"Uniting Gametes\",\"Freq. before selection\",\"Freq. weighted by fitness\", \"Freq. after selection\",\"A\",\"a\"])\n\n4 rows √ó 6 columns (omitted printing of 2 columns)\n\n\n\n\nUniting Gametes\nFreq. before selection\nFreq. weighted by fitness\nFreq. after selection\n\n\n\nLaTeXStr‚Ä¶\nNum\nNum\nNum\n\n\n\n\n1\nA √ó A\np^2\nW·¥¨·¥¨*(p^2)\n(W·¥¨·¥¨*(p^2)) / WÃÑ\n\n\n2\nA √ó a\np*q\nW·¥¨·µÉ*p*q\n(W·¥¨·µÉ*p*q) / WÃÑ\n\n\n3\na √ó A\np*q\nW·¥¨·µÉ*p*q\n(W·¥¨·µÉ*p*q) / WÃÑ\n\n\n4\na √ó a\nq^2\nW·µÉ·µÉ*(q^2)\n(W·µÉ·µÉ*(q^2)) / WÃÑ\n\n\n\n\n\n\nHmmm‚Ä¶ Could be bit prettier‚Ä¶\n\nlatexify(matingTable)\n\n\n\n\n\n\n\n\n\n\n\n\nUniting Gametes\nFreq. before selection\nFreq. weighted by fitness\nFreq. after selection\nA\na\n\n\n\n\n\\(A √ó A\\)\n\\(p^{2}\\)\n\\(p^{2} W^{A A}\\)\n\\(\\frac{p^{2} W^{A A}}{\\textnormal{\\={W}}}\\)\n\\(1\\)\n\\(0\\)\n\n\n\\(A √ó a\\)\n\\(p q\\)\n\\(W^{A a} p q\\)\n\\(\\frac{W^{A a} p q}{\\textnormal{\\={W}}}\\)\n\\(\\frac{1}{2}\\)\n\\(\\frac{1}{2}\\)\n\n\n\\(a √ó A\\)\n\\(p q\\)\n\\(W^{A a} p q\\)\n\\(\\frac{W^{A a} p q}{\\textnormal{\\={W}}}\\)\n\\(\\frac{1}{2}\\)\n\\(\\frac{1}{2}\\)\n\n\n\\(a √ó a\\)\n\\(q^{2}\\)\n\\(q^{2} W^{a a}\\)\n\\(\\frac{q^{2} W^{a a}}{\\textnormal{\\={W}}}\\)\n\\(0\\)\n\\(1\\)\n\n\n\n\n\nNice. So now lets use the table to generate a model of the dynamics of alleles \\(p\\) and \\(q\\). First we multiply the the frequencies after selection by the proportions of A gametes produced and sum over rows.\n\np‚Çú‚Çä‚ÇÅ = sum(matingTable[:,\"A\"] .* matingTable[:,\"Freq. after selection\"])\n\n\\[ \\begin{equation}\n\\frac{p^{2} W^{A A}}{\\textnormal{\\={W}}} + \\frac{W^{A a} p q}{\\textnormal{\\={W}}}\n\\end{equation}\n\\]\n\n\nNext lets substitute in some fitness values and build our recursion function.\n\nW·¥¨·¥¨, W·¥¨·µÉ, W·µÉ·µÉ = 1.2, 1.7, 1.0 # heterozygote advantage\np‚Çú‚Çä‚ÇÅ = substitute(p‚Çú‚Çä‚ÇÅ, [W·¥¨·¥¨ =&gt; W·¥¨·¥¨, W·¥¨·µÉ =&gt; W·¥¨·µÉ])\np_func = eval(build_function(p‚Çú‚Çä‚ÇÅ,p, q, WÃÑ))\n\n#19 (generic function with 1 method)\n\n\nOkay, so now we need to pick initial values for \\(p\\) and \\(q\\) and define a WÃÑ function. We will do the latter inside of a let block as we cant otherwise redefine the variable WÃÑ as a function. Then we just run through a loop repeatedly solving the recursion equation, and plot the results.\n\np = [0.1] # ‚üπ q = [0.9]\nlet WÃÑ(p,q) = p^2*W·¥¨·¥¨ + 2p*q*W·¥¨·µÉ + q^2*W·µÉ·µÉ\n  for i in 1:30\n    push!(p,p_func(p[end], 1 - p[end], WÃÑ(p[end],1 - p[end])))\n  end\n  fig, ax, plt = lines(0:30, p,label = L\"p(t)\")\n  lines!(0:30, 1 .- p, label = L\"q(t)\")\n  ax.xlabel = \"t\"\n  ax.ylabel = \"Allele frequency\"\n  axislegend(ax)\n  fig\nend"
  },
  {
    "objectID": "otto_day/otto_day_01.html",
    "href": "otto_day/otto_day_01.html",
    "title": "1. Mathematical Modelling in Biology",
    "section": "",
    "text": "Science will progress faster and further by a marriage of mathematical and empirical biology. This marriage will be even more successful if more biologists can use math, when needed, to advance their own research goals.\n\n\nIntro\nThis chapter serves as a motivational one, highlighting the importance and usefulness of mathematical modelling in biology. To be fair, this is not a small book, and I‚Äôd be surprised if many biologists got as far as picking it up, without already being fairly motivated!. They start by discussing the sheer number of published articles using mathematical models of some kind (Table¬†1), and the ability of models to say a lot, with only an handful of symbols (you will of course need to read the book if you want to hear what this models are saying). The meat of the chapter takes the form of a case study of the role of mathematical modelling in understanding/predicting trajectories in the HIV/AIDS epidemic. This is put forward as a clear example of a hugely important application, and one where models have been essential in producing testable predictions and generating forecasts for use in prevention and healthcare interventions. I‚Äôm going to briefly mention 3 of the examples mentioned in the book. I won‚Äôt really go into the how‚Äôs or why‚Äôs of the maths, as we haven‚Äôt covered any of that in the book yet. Instead I‚Äôll share code examples of how we can recreate (or expand upon) figures presented in the book and the associated primary literature, to show what we will be able to do once we‚Äôve progressed and started developing our own models.\n\n\n\n\n\n\nNote\n\n\n\nThis page (unlike most others in the site) requires WebGL in order to view the visualisations. If you are using the Safri browser, you may have to enable WebGL\n\n\n\n\n\n\n\n\n\n\n\n\n\nTable¬†1: Use of mathematical models in journal articles\n\n\nJournal (in 2001)\nNumber of articles\nGenral use of models\nSpecific use of models\nEquations Presented\n\n\n\n\nAmerican Naturalist\n105\n96\\%\n59\\%\n58\\%\n\n\nEcology\n274\n100\\%\n35\\%\n38\\%\n\n\nEvolution\n231\n100\\%\n35\\%\n33\\%\n\n\n\n\n\n\n\n\n\n\n\nDynamics of HIV After Initial Infection\nHere the authors discuss a paper by Andrew Phillips (1996) which used a mathematical model to show that it is at least plausible that the drop off in the number of virions in a patient (following an early peak) is a simple consequence of a decline in the number of the particular cells (CD4+ T cells) that HIV infects. Previously it was assumed that this drop off was due to immune response. However, by modelling the dynamics of immune cells and HIV virions without any change in immune response, Phillips showed that it is possible to see the same pattern of early peak followed by decline, based solely on the population dynamics of virions and immune cells.\nThe model includes uninfected CD4 lymphocytes (\\(R\\)), latently infected cells (\\(L\\)), actively infected cells (\\(E\\)), and free virions (\\(V\\)). Activated, uninfected CD4 lymphocytes arise at a constant rate \\(\\Gamma_{\\tau}\\) and they are removed by HIV-independent death at rate \\(\\mu\\), or by infection at rate \\(\\beta V\\).\n\\[\n\\frac{d R}{d t}=\\Gamma \\tau-\\mu R-\\beta R V\n\\]\nUpon infection, a proportion \\(p\\) of cells become latently infected, and are removed by HIV-independent cell death or by activation at rate \\(\\alpha\\) \\[\n\\frac{d L}{d t}=p \\beta R V-\\mu L-\\alpha L\n\\]\nActively infected cells are generated immediately after infection or from the activation of latently infected cells before they die at rate \\(\\delta\\) \\[\n\\frac{d E}{d t}=(1-p) \\beta R V+\\alpha L-\\delta E\n\\] Free virions are produced at rate \\(\\pi\\) by actively infected cells and removed at rate \\(\\sigma\\) \\[\n\\frac{d V}{d t}=\\pi E-\\sigma V\n\\] And the total number of CD4 lymphocytes is \\[\n1000(1 - \\tau) + R + L + E\n\\]\nGiven these equations and the parameter values and starting densities in the paper, we can recreate Figure 1.5 form the book. In fact we‚Äôll go one better and reproduce Figure 1 A from the paper, which additionally includes the number of CD4 cells with a different y-axis scale from the number of virions.\nFirst we list the parameter values from the paper, and collect them in a vector.\n\nŒì = 1.36\nŒº = 1.36e-3\nœÑ = 0.2 \nŒ≤ = 0.00027\np = 0.1 \nŒ± = 3.6e-2\nœÉ = 2 \nŒ¥ = 0.33\nœÄ = 100\nP = [Œì, Œº, œÑ, Œ≤, p, Œ±, œÉ, Œ¥, œÄ]\n\nNext we define our system of equations within a function.\n\nusing DifferentialEquations\n# Define a differential equation function\nfunction phillips‚Çâ‚ÇÜ(du,u,P,t)\n    Œì, Œº, œÑ, Œ≤, p, Œ±, œÉ, Œ¥, œÄ = P # Unpack the parameters\n    R, L, E, V = u[1:4]           # Unpack the variables\n\n    du[1] = Œì*œÑ - Œº*R - Œ≤*R*V     #dR/dt\n    du[2] = p*Œ≤*R*V -Œº*L - Œ±*L    #dL/dt\n    du[3] = (1-p)Œ≤*R*V + Œ±*L -Œ¥*E #dE/dt\n    du[4] = œÄ*E - œÉ*V             #dV/dt\nend\n\nNow we have our function and our parameter values, all we need are initial values for the variables (I‚Äôve taken these from the paper also) and a timespan we are interested in.\n\n\n\n\n\n\nNote\n\n\n\nWhen implementing someone else‚Äô model take care with the timespan. Here the author of the paper state that their rate parameters are rates of change per day. Thus, the first 120 days is t = 0 to t = 120, but that won‚Äôt always be the case.\n\n\n\n# Define and ordinary differential equation problem\nprob = ODEProblem(phillips‚Çâ‚ÇÜ,            # Function\n                  [200.0,0.0,0.0,4e-7],  # Variables inital values\n                  (0.0,120),             # Time span\n                  P)                     # Parameter values\n\n# Solve the problem \nsol = solve(prob,              # The ODEProblem defined above\n            reltol = 0.5e-9,    # Decreased \"relative tolerance\" as default value\n                               # led to slight innacuracy towards end of simulation\n            saveat = 1)        # Store a point at each interger value of t, for plotting \n\nNow we are ready to plot. Notice in the code above I manually set the reltol argument in the solve function. I only realised that I had to do this because I had a reference output, i.e.¬†my plot did not match the plot from the paper until I lowered reltol. Figure 1 A from the paper has two lines with different y-axis scales, so I thought it would be nice to show one approach to achieving this in Julia using the Makie plotting library.\n\nusing WGLMakie\ns = Array(sol)'                \nfig = Figure()\nax1 = Axis(fig[1,1],xticks = 0:30:120, \n           xgridvisible = false, ygridvisible = false,\n           xlabel = \"days\", ylabel = \"lymphocytes\")\nax2 = Axis(fig[1,1],yaxisposition = :right, \n           xgridvisible = false, ygridvisible = false,\n           ylabel = \"virions\")\nlines!(ax1,(1000(1 - œÑ) .+ s[:,1] .+ s[:,2] .+ s[:,3])[1:end], \n        color = :black)\nlines!(ax2,log10.(s[:,4]), color = :black)                     \nax2.yticks = (log10.([0.1,1,10,100,1000,10000]),              \n              string.([0.1,1,10,100,1000,10000]))            \nylims!(ax2,(-1,log10(10000)))\nylims!(ax1,0.0,1200)\nhidexdecorations!(ax2)\ntext!(ax1, \"CD4 lymphocytes\", position = (45,825))\ntext!(ax2, \"Cell-free virus\", position = (40,1))\nfig\n\n\n\n  \n    \n  \n  \n  \n  \n  \n  \n  \n\nFigure¬†1: Phillips 1996\n\n\n\n\n\nThe Effects of Antiretroviral Therapy on the Spread of HIV\nIn the next paper Blower et al.¬†(2000) try to assign probabilities to the range of possible outcomes following the introduction of antiretroviral therapies (ART). Essentially, ART was such a huge step forward in treating HIV that it could (indeed did) lead to an increase in ‚Äúrisky‚Äù behaviour (see unprotected sex). The model in this paper then sought to predict the possible fate of the gay community in San Francisco for a range of parameter values pertaining to infection rates, effectiveness of ART etc. but also the increase in risky behaviour caused by the existence of ART. This was a nice example of thoroughly investigating a broad parameter space, and of providing honest, probabilistic answers rather than overconfident point estimates. Moreover, it was a clever (and important!) touch to model changes in behaviour alongside physiological processes.\nIn the book, they present a simplified version of the model (see Box 2.5 in the next chapter) and they show in Figure 1.6 how the impact of ART can vary with it‚Äôs associated increase in risk behaviour \\(i\\). Since this is a digital resource, we can go one better and make an interactive plot. Don‚Äôt worry too much about the code for for the equations as this is much the same procedure as above.\n\n\nCode\n# parameter values from the paper\nœÄ = 2133\nŒº = 1/30\nc = 1.7\nŒ≤·µ§ = 0.1\nŒ≤‚Çú = 0.025\nœÉ = 0.5\ng = 0.05\nŒΩ·µ§ = 1/12\nŒΩ‚Çú = 1/27\nfunction blower‚ÇÄ‚ÇÄ(du,u,P,t)\n    œÄ, Œº,c, Œ≤·µ§, Œ≤‚Çú, œÉ, g, ŒΩ·µ§, ŒΩ‚Çú, i = P\n    X, Y·µ§, Y‚Çú = u\n    Œª = (Œ≤·µ§*Y·µ§ + Œ≤‚Çú*Y‚Çú)/(X + Y·µ§ + Y‚Çú)\n\n    du[1] = œÄ - c*(1 + i)Œª*X - Œº*X\n    du[2] = c*(1 + i)Œª*X + g*Y‚Çú - œÉ*Y·µ§ - Œº*Y·µ§ - ŒΩ·µ§*Y·µ§\n    du[3] = œÉ*Y·µ§ - g*Y‚Çú - Œº*Y‚Çú - ŒΩ‚Çú*Y‚Çú\nend\n\n\nWe will need some derived quantities for this. To get the cumulative number of AIDS related deaths, we will numerically integrate the ODE solution over the relevant timespan to get the number of infected individuals receiving ART and those not, and then multiply by their respective death rates. We compare the number of deaths for a given set of parameter values with the number of deaths without ART i.e.¬†when the rate at which people begin treatment \\(\\sigma\\) and the increase in risky behaviour \\(i\\) both = 0.\n\n\nCode\nusing QuadGK\n\nfunction deaths(sol,t, ŒΩ·µ§ = 1/12, ŒΩ‚Çú = 1/27)\n    AUC, err = quadgk(sol, 0, t)\n    AUC[2]ŒΩ·µ§ +AUC[3]ŒΩ‚Çú\nend\n\nfunction get_z(i, tmax = 10, tmin = 1, step = 1)\n    P = [œÄ, Œº,c, Œ≤·µ§, Œ≤‚Çú, œÉ, g, ŒΩ·µ§, ŒΩ‚Çú, i]\n    prob = ODEProblem(blower‚ÇÄ‚ÇÄ, \n        [0.7,0.3,0.0] .*40000,  \n        (0.0,10),\n        P)  \n    sol = solve(prob)\n    ARTdeaths = [deaths(sol,t) for t in tmin:step:tmax]\n    P = [œÄ, Œº,c, Œ≤·µ§, Œ≤‚Çú, 0, g, ŒΩ·µ§, ŒΩ‚Çú, 0]\n    prob = ODEProblem(blower‚ÇÄ‚ÇÄ, \n        [0.7,0.3,0.0] .*40000, \n        (0.0,10),\n        P)  \n    sol = solve(prob)\n    NULLdeaths = [deaths(sol,t) for t in tmin:step:tmax]\n    z =  ARTdeaths ./ NULLdeaths \n    vcat(0,(1 .- z)*100) # zero at the begining, for plotting purposes\nend\n\n\nNow we are ready to plot.\n\nLocalOnline\n\n\nHow I would make an interactive plot for personal use.\nusing GLMakie\nfig = Figure()\nax = Axis(fig[1, 1], xlabel = \"Years\", \n          ylabel = \"Percent of AIDS deaths averted\",\n          xticks = 2:2:10, xgridvisible = false, ygridvisible = false)\n# Create a slider widget\ni_slider = Slider(fig[2,1],range = 0:0.01:3.0)\n# Create a vector 'z' which is the return value from calling\n# get_z() on the slider value\nz = lift(i_slider.value) do i\n    get_z(i)\nend\nlines!(0:10,z, color = :red, linewidth = 5)\nlimits!(ax, 0, 10, 0, 50)\nfig\n\n\nHow I made this one to share online. see here for details.\nusing JSServe, WGLMakie\nPage(exportable=true, offline=true)\nWGLMakie.activate!()\nApp() do session::Session\n  fig = Figure()\n  ax = Axis(fig[1, 1], xlabel = \"Years\", \n            ylabel = \"Percent of AIDS deaths averted\",\n            xticks = 2:2:10, xgridvisible = false, ygridvisible = false)\n  # Create a slider widget\n  i_slider = Slider(0:0.01:3.0) \n  # Create a vector 'z' which is the return value from calling\n  # get_z() on the slider value\n  z = lift(i_slider.value) do i\n      get_z(i)\n  end\n  lines!(0:10,z, color = :red, linewidth = 5)\n  limits!(ax, 0, 10, 0, 50)\n  slider = DOM.div(\"i: \", i_slider, i_slider.value)\n  return JSServe.record_states(session, DOM.div(slider, fig))\nend\n\n\n\n\n\n\n  \n    i: \n      \n      0.0\n    \n    \n      \n    \n  \n  \n  \n  \n\n\n\nAs we can see, if behavioural changes are too extreme there is predicted to be a net negative effect of ART over the 10 year period!\n\n\nPredicting the Number of New Infections\nContinuing the theme of models working together with data, here the authors present a 2001 paper by Williams et al. which developed a novel model for predicting age-specific risks of contracting HIV from (in some cases very sparse) data on prevalence of HIV. Aside from being a useful contribution, giving people the tools to make targeted decisions about where to focus resources in the battle against HIV/AIDS, they also take a really interesting approach to the maths. Unlike the other models discussed above, this is not system of differential equations but instead they fit a modified log-normal function with well reasoned (backed by evidence shown in the paper) assumptions, parameter values and choices of functions. The authors fit their model to data using maximum likelihood estimation and subsequently estimate confidence intervals by a monte-carlo procedure, all in bespoke Visual Basic code. Thankfully, with modern probabilistic programming languages PPLs like Turing.jl now we can fit arbitrarily complex functions to data in easy, human-readable syntax, like so‚Ä¶\n@model function hiv(age, tot, pos)\n    # priors\n    N ~ truncated(Cauchy(0,30), lower = 0.0)\n    m ~ truncated(Cauchy(0,30), lower = 0.0)\n    œÉ ~ Exponential()\n    # transformed variables\n    x = P.(age,N,m,œÉ)\n    # likelihood\n    pos .~ Binomial.(tot,x)\nend\nwhere age, tot, and pos are vectors or age groups (age in years) and their corresponding counts of total tested and the number found to be HIV positive. N, m, œÉ are parameters to be inferred and P is a function to compute the prevalence of HIV (for a given age group at a certain time) given those parameters. Thus, once we have figured out the appropriate functions to model reality (the hard part!) we can do full Bayesian inference and get a decent picture of our uncertainty around not only our parameter values but (more importantly in cases like this) our predictions.\n\n\nCode\nusing Turing, StatsFuns\n# The data are emebded in a text file that I extracted from the pdf\n# of the paper.\ntbl = split.(readlines(\"out.txt\")[225:260])\nage = parse.(Int, [t[1] for t in tbl])\ntot = parse.(Int, [t[2] for t in tbl])\npos = parse.(Int, [t[3] for t in tbl])\nobs = parse.(Float64, [t[4] for t in tbl])\n# I'm wrapping everything in a `let` block so I can reassign some\n# previousy used variable names as function names in  the local scope.\nlet a‚ÇÄ = 10.0 \n    œÄ = Base.œÄ # re-assign œÄ it's normal value\n    # Equations from the paper\n    P(t) = logistic(0.372t ‚àí 744.6)\n    function Œº(aÃÇ,aÃÉ) \n    d =  aÃÇ - aÃÉ\n    d &gt; 2 ? mort(d -2) : 1.0\n    end\n    mort(diff) = exp(-diff/(7/log(2)))\n    f(a,N,m,œÉ,t) = R(a,N,m,œÉ)P(t)\n    R(a,N,m,œÉ) = a &gt; a‚ÇÄ ? N/(œÉ‚àö(2œÄ)*(a-a‚ÇÄ))*exp(-(log(a-a‚ÇÄ) - log(m))^2 /2œÉ^2) : 0.0\n    s(a,N,m,œÉ,t = 1998) = exp(-sum(f.(0:a,N,m,œÉ,t-a:t)))\n    c(a,N,m,œÉ,t = 1998) = sum( [Œº(a,aÃÉ)*f(aÃÉ,N,m,œÉ,t-(a-aÃÉ))*s(aÃÉ,N,m,œÉ,t-(a-aÃÉ)) for aÃÉ in 0:a])\n    function P(a,N,M,œÉ,t = 1998)\n        s‚Çê‚Çú = s(a,N,M,œÉ,t)\n        c‚Çê‚Çú = c(a,N,M,œÉ,t)\n        c‚Çê‚Çú/(c‚Çê‚Çú + s‚Çê‚Çú)\n    end\n    # Probablistic model\n    @model function hiv(age, tot, pos)\n\n        N ~ truncated(Cauchy(0,30), lower = 0.0)\n        m ~ truncated(Cauchy(0,30), lower = 0.0)\n        œÉ ~ Exponential()\n\n        x = P.(age,N,m,œÉ)\n        pos .~ Binomial.(tot,x)\n        # return some generated quatities, to be extracted for plotting\n        return [P.(10:50,N,m,œÉ,1998), f.(10:50,N,m,œÉ,1998)]\n    end\n    # Fit model to data using 200 iterations of No U-Turns Sampler (NUTS)\n    hivmod = hiv(age, tot, pos)\n    chn = sample(hivmod, NUTS(), 200)\n    # Extract generated quanities for plotting\n    gens = generated_quantities(hivmod, chn)\n    # Plot\n    fig,ax,plt =scatter(age,obs)\n    lines!.(ax,[hcat(10:50,gen[1]) for gen in gens], color = (:grey,0.1))\n    lines!.(ax,[hcat(10:50,gen[2]) for gen in gens], color = (:red,0.1))\n    text!(ax, \"newly infected \\\"risk\\\"\", position = (18,0.02))\n    text!(ax, \"prevalence\", position = (30,0.45))\n    ax.xlabel = \"Age in years\"\n    ax.ylabel = \"Proportion of women\"\n    hidedecorations!(ax, ticklabels = false, label = false)\n    fig\nend\n\n\n\n  \n    \n  \n  \n  \n  \n\n\n\n\n\nConcluding Remarks\nFor me, this opening chapter really hit the mark. The HIV/AIDS case study was well chosen, since the nature of the infection meant that ecological (population dynamics) and evolutionary (mutation limitation) theory were employed both to understand the plausible range of processes going on during infection and to design treatments against a rapidly evolving antagonist. Thus, I was at once hit with the excitement of scientific discovery (guided by insights gleaned form models) and reminded that immediate and substantial human benefits can be derived from these insights. However, In their concluding message for the chapter Otto & Day also stress the limitations of mathematical modelling. For one, modelling results are only as interesting as the question(s) being asked. This is an obvious but important point. It is easy to become disillusioned when frequently confronted models that seem to have been formulated just for the sake of it. They then go on to stress the importance of a ‚Äúmarriage of mathematical and empirical biology‚Äù, stating that facilitating this indeed is the purpose of the book. Unfortunately, it is quite common to encounter the disconnect that often (but not always) exists between modelling and data, so I am glad that this is their aim. But as a final remark on the quality of this first chapter, the concluding message was not really needed. The examples presented throughout made it clear how powerful a proper marriage of theory and data can be when done properly and when asking the right questions."
  },
  {
    "objectID": "mymods/symbiont.html",
    "href": "mymods/symbiont.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "+++ weave = true +++ @def title = ‚Äúsymbiont‚Äù\ninsert_weave _assets/symbiont.jmd"
  },
  {
    "objectID": "menu3.html",
    "href": "menu3.html",
    "title": "Bayesian Data Analysis Demos",
    "section": "",
    "text": "@def title = ‚ÄúMenu 3‚Äù"
  },
  {
    "objectID": "menu3.html#chapter-2",
    "href": "menu3.html#chapter-2",
    "title": "Bayesian Data Analysis Demos",
    "section": "Chapter 2",
    "text": "Chapter 2\ndemo1"
  },
  {
    "objectID": "menu1.html",
    "href": "menu1.html",
    "title": "The Ecological Detective",
    "section": "",
    "text": "+++ title = ‚ÄúEcological Detective‚Äù hascode = true date = Date(2019, 3, 22) rss = ‚ÄúThese pages won‚Äôt have much text. All the text is in the book. This is just for implementation (code) details.‚Äù +++ @def tags = [‚Äúsyntax‚Äù, ‚Äúcode‚Äù]"
  },
  {
    "objectID": "menu1.html#chapter-1-and-2",
    "href": "menu1.html#chapter-1-and-2",
    "title": "The Ecological Detective",
    "section": "Chapter 1 and 2",
    "text": "Chapter 1 and 2\nThere‚Äôs not a lot of maths here, so I‚Äôve just included a bit of visualisation to go with Box 2.1"
  },
  {
    "objectID": "games/resistance.html",
    "href": "games/resistance.html",
    "title": "Resistance",
    "section": "",
    "text": "This game is intended to accompany a lesson teaching young children some basic concepts about bacteria and antibiotics:\n\nMany of the bacteria in our bodies are actually good for us.\nAntibiotics are a very powerful tool for dealing with harmful bacterial infections.\nUsing antibiotics when they are not needed can lead to antibiotic resistance. Meaning that antibiotic treatments may be inefective when we need them most."
  },
  {
    "objectID": "games/resistance.html#learning-outcomes",
    "href": "games/resistance.html#learning-outcomes",
    "title": "Resistance",
    "section": "",
    "text": "This game is intended to accompany a lesson teaching young children some basic concepts about bacteria and antibiotics:\n\nMany of the bacteria in our bodies are actually good for us.\nAntibiotics are a very powerful tool for dealing with harmful bacterial infections.\nUsing antibiotics when they are not needed can lead to antibiotic resistance. Meaning that antibiotic treatments may be inefective when we need them most."
  },
  {
    "objectID": "games/resistance.html#premise",
    "href": "games/resistance.html#premise",
    "title": "Resistance",
    "section": "Premise",
    "text": "Premise\nYou are being sent on a special mission to help look after a patient recovering from a recent surgery. You will be shrunk down to microscopic size (too small to see with just your eyes!) so that you can pilot a special medical nanoship. Your mission is to pilot the ship through the patients‚Äô bloodstream, destroying any harmful bacteria you come across. But be careful! Many bacteria are incredibly useful for human health, so we don‚Äôt want to kill these helpful bacteria. You wouldn‚Äôt be able to tell good from bad just by looking at them, so to make things easier, any harmful bacteria will appear red and angry in your display, while the helpful ones will look green and peaceful.\nThere are two ways you can destroy the bacteria you encounter. One is to use your laser cannon. The other is to use antibiotics. Antibiotics are an incredibly important type of medicine. They can be very effective for treating bacterial infections. However, some bacteria have special ways of surviving antibiotics. This is called antibiotic resistance. When antibiotics kill off lots of bacteria, the resistant ones are able to grow quickly and take their place. They pass on their resistance to their offspring and even to other bacteria that they are not related to.\nOur hope is that you will be able to kill off an infection of harmful bacteria if one arrives. So be careful not to use antibiotics when they are not needed, or you may find yourself facing lots of harmful, resistant bacteria! When using your lasers, remember that you only want to shoot the harmful bacteria. Letting them escape will harm the patient, but so will shooting the helpful bacteria. To help remind you of this, we have set up a scoring system: you get 100 points for shooting down a harmful bacterium and lose 50 points for destroying a helpful bacterium."
  },
  {
    "objectID": "games/resistance.html#gameplay",
    "href": "games/resistance.html#gameplay",
    "title": "Resistance",
    "section": "Gameplay",
    "text": "Gameplay\n\nUse the arrow keys to move in the desired direction.\nCrashing into bacteria will end the game.\n\n\nThe space bar fires lasers.\nTwo shots will kill a harmful bacterium, and one shot will kill a helpful bacterium. Killing the helpful bacteria harms the patient.\n\n\nThe Enter button releases antibiotics.\nThis kills all bacteria currently in view, but also increases the amount of antibiotic resistance."
  },
  {
    "objectID": "games/resistance.html#display",
    "href": "games/resistance.html#display",
    "title": "Resistance",
    "section": "Display",
    "text": "Display\nOn the top right of the screen, a pill icon shows the current effectiveness of antibiotics. The more greyed out the pill, the more bacteria will be resistant to you antibiotics!\nThe patient is also shown in the bottom right. His health is reduced whenever harmful bacteria escape or helpful bacteria are killed. The game ends if the patient gets too sick (when the patient icon is completely grey)!\nOn the top left is the players‚Äô current score: 100 points for shooting a harmful bacteria; -50 for shooting a helpful bacteria."
  },
  {
    "objectID": "config.html",
    "href": "config.html",
    "title": "Add here files or directories that should be ignored by Franklin, otherwise",
    "section": "",
    "text": "+++ author = ‚ÄúArthur Newbury‚Äù mintoclevel = 2\n\nAdd here files or directories that should be ignored by Franklin, otherwise\n\n\nthese files might be copied and, if markdown, processed by Franklin which\n\n\nyou might not want. Indicate directories by ending the name with a /.\n\n\nBase files such as LICENSE.md and README.md are ignored by default.\nignore = [‚Äúnode_modules/‚Äù]\n\n\nRSS (the website_{title, descr, url} must be defined to get RSS)\ngenerate_rss = true website_title = ‚ÄúFranklin Template‚Äù website_descr = ‚ÄúExample website using Franklin‚Äù website_url = ‚Äúhttps://tlienart.github.io/FranklinTemplates.jl/‚Äù +++\n\n@def weave = false"
  },
  {
    "objectID": "BDA/ch2/demo2_1.html",
    "href": "BDA/ch2/demo2_1.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "+++ weave = true +++ @def title = ‚Äúdemo 2 1‚Äù\n{{insert_weave _assets/demo21.jmd}}"
  },
  {
    "objectID": "admin.html",
    "href": "admin.html",
    "title": "admin",
    "section": "",
    "text": "Shift files around for doc deploy\n\n\nCode\nusing GLMakie, FileIO\n\nimg = load(\"./media/spcow.jpg\")\nsave(\"./docs/spcow.jpg\",img)\n\n\n42032"
  },
  {
    "objectID": "bayes/examples/antibiotics.html",
    "href": "bayes/examples/antibiotics.html",
    "title": "(proportions of) Cell Counts",
    "section": "",
    "text": "As a microbiologist (of sorts), one thing I do far too much of (or far too little of, depending on whether you‚Äôre ask me or my supervisor) is plating bacteria on agar plates to count colony forming units (CFUs). The basic idea is to dilute down your bacterial culture to a point where you can spread a small drop of diluted culture across a nutrient rich surface, leave them at a temperature the bacteria like for a day or two, then count the number of colonies that grow to estimate the density of live cells in your culture.\nIn a recent experiment, a colleague and I wanted to use selective plates to determine the frequency of an antibiotic resistance conferring plasmid plasmid in a synthetic microbial community. The idea is to compare colony counts on normal agar plates with the counts from plates laced with antibiotics. The ratio of colonies detected on the selective plates to those found on the normal plates is the proportion of bacterial cells that carry the plasmid. Simple!‚Ä¶ Except, not really. In fact we often found more bacteria on the selective plates than the normal ones. Yes, we could publish these ratios of greater than 1 and be those genius scientists who proved unequivocally that antibiotics cause additional bacteria to materialise. But actually what the data show is that even if we had only seen ratios &lt; 1 we should not have just used them as is. This is fairly common. When we see what we expect, we just report the results. But when things look a bit iffy we realise that our whole statistical methodology was flawed all along. The astute among you will see that this can be a huge source of bias!"
  },
  {
    "objectID": "bayes/examples/antibiotics.html#motivation",
    "href": "bayes/examples/antibiotics.html#motivation",
    "title": "(proportions of) Cell Counts",
    "section": "",
    "text": "As a microbiologist (of sorts), one thing I do far too much of (or far too little of, depending on whether you‚Äôre ask me or my supervisor) is plating bacteria on agar plates to count colony forming units (CFUs). The basic idea is to dilute down your bacterial culture to a point where you can spread a small drop of diluted culture across a nutrient rich surface, leave them at a temperature the bacteria like for a day or two, then count the number of colonies that grow to estimate the density of live cells in your culture.\nIn a recent experiment, a colleague and I wanted to use selective plates to determine the frequency of an antibiotic resistance conferring plasmid plasmid in a synthetic microbial community. The idea is to compare colony counts on normal agar plates with the counts from plates laced with antibiotics. The ratio of colonies detected on the selective plates to those found on the normal plates is the proportion of bacterial cells that carry the plasmid. Simple!‚Ä¶ Except, not really. In fact we often found more bacteria on the selective plates than the normal ones. Yes, we could publish these ratios of greater than 1 and be those genius scientists who proved unequivocally that antibiotics cause additional bacteria to materialise. But actually what the data show is that even if we had only seen ratios &lt; 1 we should not have just used them as is. This is fairly common. When we see what we expect, we just report the results. But when things look a bit iffy we realise that our whole statistical methodology was flawed all along. The astute among you will see that this can be a huge source of bias!"
  },
  {
    "objectID": "bayes/examples/antibiotics.html#video-proof-of-correctness-of-poisson-distribution",
    "href": "bayes/examples/antibiotics.html#video-proof-of-correctness-of-poisson-distribution",
    "title": "(proportions of) Cell Counts",
    "section": "Video proof of correctness of Poisson distribution",
    "text": "Video proof of correctness of Poisson distribution"
  },
  {
    "objectID": "bayes/examples/antibiotics.html#develop-model",
    "href": "bayes/examples/antibiotics.html#develop-model",
    "title": "(proportions of) Cell Counts",
    "section": "Develop model",
    "text": "Develop model"
  },
  {
    "objectID": "bayes/examples/antibiotics.html#hierachical-version",
    "href": "bayes/examples/antibiotics.html#hierachical-version",
    "title": "(proportions of) Cell Counts",
    "section": "Hierachical version",
    "text": "Hierachical version"
  },
  {
    "objectID": "bayes/examples/antibiotics.html#validate-model",
    "href": "bayes/examples/antibiotics.html#validate-model",
    "title": "(proportions of) Cell Counts",
    "section": "Validate model",
    "text": "Validate model"
  },
  {
    "objectID": "BDA/ch2/index.html",
    "href": "BDA/ch2/index.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "+++ weave = true +++\n{{insert_weave _assets/demo21.jmd}}"
  },
  {
    "objectID": "ecodetect/box_2_1.html",
    "href": "ecodetect/box_2_1.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "+++ weave = true +++ @def title = ‚Äúbox 2.1‚Äù\n{{insert_weave _assets/box_2_1.jmd}}"
  },
  {
    "objectID": "menu2.html",
    "href": "menu2.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "@def title = ‚ÄúMore goodies‚Äù @def hascode = true @def rss = ‚ÄúModels used in my research‚Äù @def rss_title = ‚ÄúMore goodies‚Äù @def rss_pubdate = Date(2019, 5, 1)\n@def tags = [‚Äúsyntax‚Äù, ‚Äúcode‚Äù, ‚Äúimage‚Äù] # Models used in my research"
  },
  {
    "objectID": "menu2.html#symbiont-network-dynamics",
    "href": "menu2.html#symbiont-network-dynamics",
    "title": "Arthur Newbury",
    "section": "Symbiont Network Dynamics",
    "text": "Symbiont Network Dynamics"
  },
  {
    "objectID": "menu4.html",
    "href": "menu4.html",
    "title": "Mathematical Models of Social Evolution",
    "section": "",
    "text": "+++ title = ‚ÄúMathematical Models of Social Evolution‚Äù hascode = true date = Date(2019, 3, 22) rss = ‚ÄúThese pages won‚Äôt have much text. All the text is in the book. This is just for implementation (code) details.‚Äù +++ @def tags = [‚Äúsyntax‚Äù, ‚Äúcode‚Äù]"
  },
  {
    "objectID": "menu4.html#chapter-1",
    "href": "menu4.html#chapter-1",
    "title": "Mathematical Models of Social Evolution",
    "section": "Chapter 1",
    "text": "Chapter 1"
  },
  {
    "objectID": "otto_day/index.html",
    "href": "otto_day/index.html",
    "title": "Overview",
    "section": "",
    "text": "This is a modern classic textbook and reference for ecologists and evolutionary biologists aiming to gain a better understanding of mathematical modeling. The book is focussed on getting biologists up to speed, so emphasis is on learning how to use various techniques, rather than on theorem proving etc.. To that end, there are several excellent primers on the maths needed for the main text. Where computer code is needed, the authors use Mathematica, which is an excellent and intuitive framework for numerical and especially symbolic computations. However, it is not cheap, unless your institution/organisation provides you with a license! Here, I will use a FOSS alternative Julia which is excellent for numerical work. Since this website is just a collection of of Quarto notebooks, each page in this section should be runnable, if you have Quarto and Julia installed (and configured correctly!)."
  },
  {
    "objectID": "otto_day/otto_day_02.html",
    "href": "otto_day/otto_day_02.html",
    "title": "2. How to Construct a Model",
    "section": "",
    "text": "One of the take-homes of this chapter is the importance of drawing a diagram of your mental model, before it becomes a mathematical model. The easiest way to draw a simple diagram is with pen/pencil and paper, but it‚Äôs useful to know how to produce flow diagrams and life cycles like the ones in the book with your computer. This is important for inclusion in publications, presentations theses etc., but also if you just tend to keep digital notes and/or want to produce diagrams programmatically such that they will automatically update as you adjust your model. To this end I will use Tikz, which is a drawing library written in/for LaTeX. Since Tikz is code based, there is a bit of a learning curve, and you may be served better by using a free drawing tool like Inkscape if building diagrams programmatically is not particularly desirable to you. However, for building reproducible documents like this one, code is king. And if you wish to produce PDF documents, writing your diagrams directly in LaTeX has significant advantages. Thankfully, there is an interface to Tikz from Julia via the package TikzPictures. So let‚Äôs use it to recreate the Figure 2.2b: the lifecycle diagram of the effect of a cat on the number of mice in a yard.\n\n\nFirst, we need to draw a circle. We are going to define a variable called Radius to make it easier to locate certain positions on the circle where we want to place arrows. Then draw a thick lined circle of the specified radius, centred at location (0,0).\n\nusing TikzPictures\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n\"\"\")\n\n\n\n\nThe L followed by 3 quotation marks means we are using a LaTeX String, this basically means we can write LaTeX code in Julia without worrying about \\ string escapes etc. Next, we want to place an arrow on the right hand side of the circle. \\draw[-latex] means we are drawing a line with and arrow at the end of the line (‚Äúlatex‚Äù is the name of a specific type of arrowhead). Since the circle is centred at (0,0), the right hand side is at x,y coordinates (\\Radius, 0), and because we want our arrow pointing along the direction of the circle, we want our line to be in an arc with radius Radius. Since it is conventional in maths to consider points on a circle starting from the far right and going around anti-clockwise, we will arc around from 3 to - 3.\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-latex] (\\Radius, 0) arc(3:-3:\\Radius);\n\"\"\"\n)\n\n\n\n\nOh dear, the arrow head is too small to make out against our ultra thick circle. Now in order to tweak the appearance of the arrow head we will use a library (bundled with Tikz) called arrows.meta which provides it‚Äôs own arrow head styles (typically the same names as base Tikz but with a capital first letter).\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius);\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)\n\n\n\n\nNow we can add a node slightly above and to the left of the end of the arrow. Nodes are very important in Tikz. They can be used directly as labels, but they also define a specific spatial location which can be used as an anchor, allowing additional nodes and drawings to be defined relative to them. Here we place \\(n''\\) at our node location.\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius) node[above left]{$n'$};\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)\n\n\n\n\nAdditionally, we specify a label with an xshift and yshift (determined through trial and error).\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius) node[above left, label={[xshift=1.2cm, yshift=0.2cm]Predation}]{$n'$};\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)\n\n\n\n\nAnd then do the same for each arrow and voila‚Ä¶\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius) node[above left, label={[xshift=1.2cm, yshift=0.2cm]Predation}]{$n'$};\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (0, \\Radius) arc(90+3:90-3:\\Radius) node[below, label={[xshift= -1.2cm]Census}]{$n$};\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (-\\Radius, 0) arc(180+3:180-3:\\Radius) node[right, label={[xshift= -1.2cm, yshift = -1.0cm]Migration}]{$n'''$};\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (0,-\\Radius) arc(270+3:270-3:\\Radius) node[above right, label={[xshift= 1.0cm, yshift = -0.85cm]Births}]{$n''$};\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)\n\n\n\n\n\n\n\nLet‚Äôs take a stab at the flow diagaram associated with the same model (Fig. 2.4b). For this it will be good to use the positioning library, and we‚Äôll get more of a sense of using nodes as connecting points. In particular, we will start by making a circle node and naming it \\(n\\), then making a completely empty node called \\(neighbours\\). This empty node represents neighbouring areas from which other mice may migrate. rather than giving it‚Äôs location by x, y coordinates, we will specify it‚Äôs location relative to \\(n\\). Then, we can draw an arrow from one node to the other. For simplicity, we won‚Äôt mess around with arrow heads hear, and just use the default one.\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n    \\draw[thick, -&gt;] (neighbours) -- (n);\n\"\"\", preamble = \"\\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nOkay, that‚Äôs step one. But this arrow coming in is pretty meaningless without a label. We can do this by adding a node along the path from neighbours to \\(n\\).\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n    \\draw[thick, -&gt;] (neighbours) -- (n);\n    \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n\"\"\", preamble = \"\\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nAlright, that‚Äôs migration sorted. Now we can do the same for predation. I‚Äôll use a skull from the skull library, though it doesn‚Äôt look nearly as good as the one from the book. I‚Äôll also specify that the label should be sloped i.e., it will follow the angle of the path from \\(n\\) to the skull. They don‚Äôt do this in the book, but it‚Äôs a nice feature to demonstrate.\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n\"\"\", preamble = \"\\\\usepackage{skull} \\n  \\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nFinally, the loop from \\(n\\) back to itself, representing births\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n  \\path [thick, -&gt;] (n) edge [loop above]  node[above] {$b \\, n'(t)$} (n);\n\"\"\", preamble = \"\\\\usepackage{skull} \\n  \\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nWe can fine tune the positioning of the loop to try and match the book. Again, we work with degrees anti-clockwise from the right hand side.\n\nJuliaLaTeX\n\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n  \\draw [thick, -&gt;] (n) edge [out=60,in=30,looseness=4] node[below right,label={[xshift=0.4cm, yshift=-0.9cm]$b \\, n'(t)$}] {} (n);\n\"\"\", preamble = \"\\\\usepackage{skull} \\n  \\\\usetikzlibrary{positioning}\"\n)\n\n\n\\documentclass{standalone}\n\\usepackage{skull}\n\\usepackage{tikz}\n\\usetikzlibrary{positioning}\n\\begin{document}\n\\begin{tikzpicture}\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n  \\draw [thick, -&gt;] (n) edge [out=60,in=30,looseness=4] node[below right,label={[xshift=0.4cm, yshift=-0.9cm]$b \\, n'(t)$}] {} (n);\n\\end{tikzpicture}\n\\end{document}\n\n\n\n\n\n\n\n\nBelow we can see how to draw the curved dashed line seen in the flow diagram of the flu model.\n\nJuliaLaTeX\n\n\nTikzPicture(L\"\"\"\n  \\node (s)[thick, circle, minimum size=2.4cm, align = center, draw = black] at (0,0) {People \\\\ without flu \\\\ $s(t)$};\n  \\node (midway)[label={[xshift= 1.0cm, yshift=-0.8cm]$a \\, c \\, s(t) \\, n(t)$}] at (2.5cm,0cm) {};\n  \\node (n)[ thick, circle, minimum size=2.4cm, align = center, draw = black] at (6cm,0cm) {People \\\\ with flu \\\\ $n(t)$};\n  \\draw[thick, -&gt;] (s) --  (n);\n  \\path [-&gt;,draw,thick, dashed] (n) to[out=90,in=150, distance=2cm] (midway);\n\"\"\", preamble = \"\\\\usetikzlibrary{positioning}\"\n)\n\n\n\\documentclass{standalone}\n\\usepackage{tikz}\n\\usetikzlibrary{positioning}\n\\begin{document}\n\\begin{tikzpicture}\n  \\node (s)[thick, circle, minimum size=2.4cm, align = center, draw = black] at (0,0) {People \\\\ without flu \\\\ $s(t)$};\n  \\node (midway)[label={[xshift= 1.0cm, yshift=-0.8cm]$a \\, c \\, s(t) \\, n(t)$}] at (2.5cm,0cm) {};\n  \\node (n)[ thick, circle, minimum size=2.4cm, align = center, draw = black] at (6cm,0cm) {People \\\\ with flu \\\\ $n(t)$};\n  \\draw[thick, -&gt;] (s) --  (n);\n  \\path [-&gt;,draw,thick, dashed] (n) to[out=90,in=150, distance=2cm] (midway);\n\\end{tikzpicture}\n\\end{document}"
  },
  {
    "objectID": "otto_day/otto_day_02.html#life-cycle-diagrams",
    "href": "otto_day/otto_day_02.html#life-cycle-diagrams",
    "title": "2. How to Construct a Model",
    "section": "",
    "text": "First, we need to draw a circle. We are going to define a variable called Radius to make it easier to locate certain positions on the circle where we want to place arrows. Then draw a thick lined circle of the specified radius, centred at location (0,0).\n\nusing TikzPictures\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n\"\"\")\n\n\n\n\nThe L followed by 3 quotation marks means we are using a LaTeX String, this basically means we can write LaTeX code in Julia without worrying about \\ string escapes etc. Next, we want to place an arrow on the right hand side of the circle. \\draw[-latex] means we are drawing a line with and arrow at the end of the line (‚Äúlatex‚Äù is the name of a specific type of arrowhead). Since the circle is centred at (0,0), the right hand side is at x,y coordinates (\\Radius, 0), and because we want our arrow pointing along the direction of the circle, we want our line to be in an arc with radius Radius. Since it is conventional in maths to consider points on a circle starting from the far right and going around anti-clockwise, we will arc around from 3 to - 3.\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-latex] (\\Radius, 0) arc(3:-3:\\Radius);\n\"\"\"\n)\n\n\n\n\nOh dear, the arrow head is too small to make out against our ultra thick circle. Now in order to tweak the appearance of the arrow head we will use a library (bundled with Tikz) called arrows.meta which provides it‚Äôs own arrow head styles (typically the same names as base Tikz but with a capital first letter).\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius);\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)\n\n\n\n\nNow we can add a node slightly above and to the left of the end of the arrow. Nodes are very important in Tikz. They can be used directly as labels, but they also define a specific spatial location which can be used as an anchor, allowing additional nodes and drawings to be defined relative to them. Here we place \\(n''\\) at our node location.\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius) node[above left]{$n'$};\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)\n\n\n\n\nAdditionally, we specify a label with an xshift and yshift (determined through trial and error).\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius) node[above left, label={[xshift=1.2cm, yshift=0.2cm]Predation}]{$n'$};\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)\n\n\n\n\nAnd then do the same for each arrow and voila‚Ä¶\n\nTikzPicture(L\"\"\"\n  \\def\\Radius{2cm}\n  \\draw [ultra thick] (0cm,0cm) circle[radius=\\Radius];\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (\\Radius, 0) arc(3:-3:\\Radius) node[above left, label={[xshift=1.2cm, yshift=0.2cm]Predation}]{$n'$};\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (0, \\Radius) arc(90+3:90-3:\\Radius) node[below, label={[xshift= -1.2cm]Census}]{$n$};\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (-\\Radius, 0) arc(180+3:180-3:\\Radius) node[right, label={[xshift= -1.2cm, yshift = -1.0cm]Migration}]{$n'''$};\n    \\draw[-{Latex[length=0.4cm, width=0.2cm]}] (0,-\\Radius) arc(270+3:270-3:\\Radius) node[above right, label={[xshift= 1.0cm, yshift = -0.85cm]Births}]{$n''$};\n\"\"\", preamble = \"\\\\usetikzlibrary{arrows.meta}\"\n)"
  },
  {
    "objectID": "otto_day/otto_day_02.html#flow-diagrams",
    "href": "otto_day/otto_day_02.html#flow-diagrams",
    "title": "2. How to Construct a Model",
    "section": "",
    "text": "Let‚Äôs take a stab at the flow diagaram associated with the same model (Fig. 2.4b). For this it will be good to use the positioning library, and we‚Äôll get more of a sense of using nodes as connecting points. In particular, we will start by making a circle node and naming it \\(n\\), then making a completely empty node called \\(neighbours\\). This empty node represents neighbouring areas from which other mice may migrate. rather than giving it‚Äôs location by x, y coordinates, we will specify it‚Äôs location relative to \\(n\\). Then, we can draw an arrow from one node to the other. For simplicity, we won‚Äôt mess around with arrow heads hear, and just use the default one.\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n    \\draw[thick, -&gt;] (neighbours) -- (n);\n\"\"\", preamble = \"\\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nOkay, that‚Äôs step one. But this arrow coming in is pretty meaningless without a label. We can do this by adding a node along the path from neighbours to \\(n\\).\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n    \\draw[thick, -&gt;] (neighbours) -- (n);\n    \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n\"\"\", preamble = \"\\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nAlright, that‚Äôs migration sorted. Now we can do the same for predation. I‚Äôll use a skull from the skull library, though it doesn‚Äôt look nearly as good as the one from the book. I‚Äôll also specify that the label should be sloped i.e., it will follow the angle of the path from \\(n\\) to the skull. They don‚Äôt do this in the book, but it‚Äôs a nice feature to demonstrate.\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n\"\"\", preamble = \"\\\\usepackage{skull} \\n  \\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nFinally, the loop from \\(n\\) back to itself, representing births\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n  \\path [thick, -&gt;] (n) edge [loop above]  node[above] {$b \\, n'(t)$} (n);\n\"\"\", preamble = \"\\\\usepackage{skull} \\n  \\\\usetikzlibrary{positioning}\"\n)\n\n\n\n\nWe can fine tune the positioning of the loop to try and match the book. Again, we work with degrees anti-clockwise from the right hand side.\n\nJuliaLaTeX\n\n\nTikzPicture(L\"\"\"\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n  \\draw [thick, -&gt;] (n) edge [out=60,in=30,looseness=4] node[below right,label={[xshift=0.4cm, yshift=-0.9cm]$b \\, n'(t)$}] {} (n);\n\"\"\", preamble = \"\\\\usepackage{skull} \\n  \\\\usetikzlibrary{positioning}\"\n)\n\n\n\\documentclass{standalone}\n\\usepackage{skull}\n\\usepackage{tikz}\n\\usetikzlibrary{positioning}\n\\begin{document}\n\\begin{tikzpicture}\n  \\node (n)[thick, circle, align = center, draw = black] at (0,0) { Number of \\\\ mice \\\\ $n(t)$};\n  \\node[left = of n] (neighbours){};\n  \\node[below right = of n] (d) {$\\skull$};\n  \\draw[thick, -&gt;] (neighbours) -- node[above]{$m$} ++ (n);\n  \\draw[thick, -&gt;] (n) -- node[sloped,above]{$d \\, n(t)$} ++ (d);\n  \\draw [thick, -&gt;] (n) edge [out=60,in=30,looseness=4] node[below right,label={[xshift=0.4cm, yshift=-0.9cm]$b \\, n'(t)$}] {} (n);\n\\end{tikzpicture}\n\\end{document}\n\n\n\n\n\n\n\n\nBelow we can see how to draw the curved dashed line seen in the flow diagram of the flu model.\n\nJuliaLaTeX\n\n\nTikzPicture(L\"\"\"\n  \\node (s)[thick, circle, minimum size=2.4cm, align = center, draw = black] at (0,0) {People \\\\ without flu \\\\ $s(t)$};\n  \\node (midway)[label={[xshift= 1.0cm, yshift=-0.8cm]$a \\, c \\, s(t) \\, n(t)$}] at (2.5cm,0cm) {};\n  \\node (n)[ thick, circle, minimum size=2.4cm, align = center, draw = black] at (6cm,0cm) {People \\\\ with flu \\\\ $n(t)$};\n  \\draw[thick, -&gt;] (s) --  (n);\n  \\path [-&gt;,draw,thick, dashed] (n) to[out=90,in=150, distance=2cm] (midway);\n\"\"\", preamble = \"\\\\usetikzlibrary{positioning}\"\n)\n\n\n\\documentclass{standalone}\n\\usepackage{tikz}\n\\usetikzlibrary{positioning}\n\\begin{document}\n\\begin{tikzpicture}\n  \\node (s)[thick, circle, minimum size=2.4cm, align = center, draw = black] at (0,0) {People \\\\ without flu \\\\ $s(t)$};\n  \\node (midway)[label={[xshift= 1.0cm, yshift=-0.8cm]$a \\, c \\, s(t) \\, n(t)$}] at (2.5cm,0cm) {};\n  \\node (n)[ thick, circle, minimum size=2.4cm, align = center, draw = black] at (6cm,0cm) {People \\\\ with flu \\\\ $n(t)$};\n  \\draw[thick, -&gt;] (s) --  (n);\n  \\path [-&gt;,draw,thick, dashed] (n) to[out=90,in=150, distance=2cm] (midway);\n\\end{tikzpicture}\n\\end{document}"
  },
  {
    "objectID": "otto_day/otto_day_02.html#discrete-time-recursion-equations",
    "href": "otto_day/otto_day_02.html#discrete-time-recursion-equations",
    "title": "2. How to Construct a Model",
    "section": "Discrete-time Recursion Equations",
    "text": "Discrete-time Recursion Equations\nHere, we will use the Symbolis‚Äôs @variables macro to define some symbolic variables to work with.\n\n@variables b d m t n‚Çú\n\n\\[ \\begin{equation}\n\\left[\n\\begin{array}{c}\nb \\\\\nd \\\\\nm \\\\\nt \\\\\nn_t \\\\\n\\end{array}\n\\right]\n\\end{equation}\n\\]\n\n\nPlugging in the equations for births, deaths and migration, we arrive at our recursion equation.\n\nn‚Ä≤ = n‚Çú*(1+b)\nn‚Ä≤‚Ä≤ = n‚Ä≤*(1-d)\nn‚Ä≤‚Ä≤‚Ä≤ = n‚Ä≤‚Ä≤+m\nn‚Çú‚Çä‚ÇÅ = n‚Ä≤‚Ä≤‚Ä≤\n\n\\[ \\begin{equation}\nm + n_t \\left( 1 + b \\right) \\left( 1 - d \\right)\n\\end{equation}\n\\]\n\n\nNow we can use the build_function erm function, to build a function that takes in \\(n(t)\\) and our parameter values, and returns \\(n(t+1)\\). To do this we call build_function on the expression we want to turn into a function, followed by the arguments we will be passing to our built function, in order. This generates some code. But we need to evaluate the code, in order to make a callable function.\n\nrecursion = eval(build_function(n‚Çú‚Çä‚ÇÅ, b, d, m, n‚Çú))\n\nNext we want to find the solution over some given time span, for particular parameter values. There are methods for solving recursion and difference equations included in DifferentialEquations, but for this simple case we can just use a loop.\n\nfunction mice_recursion(b, d, m, n‚Çú, t_max)\n    n_step = t_max + 1\n    res = Vector{Float64}(undef,n_step)\n    res[1] = n‚Çú\n    for step in 2:n_step\n        res[step] = recursion(b, d, m, res[step - 1])\n    end\n    res\nend\n\nLet‚Äôs assume there are no mice at the start, but migration is high and the death rate is slightly above the birth rate.\n\nfig,ax,rec_plt = lines(mice_recursion(0.4, 0.5, 1.5, 0.0, 100))\nax.ylabel = L\"No. mice $n$\"\nax.xlabel = L\"t\"\nfig"
  },
  {
    "objectID": "otto_day/otto_day_02.html#continuous-time-differential-equations",
    "href": "otto_day/otto_day_02.html#continuous-time-differential-equations",
    "title": "2. How to Construct a Model",
    "section": "Continuous-time Differential Equations",
    "text": "Continuous-time Differential Equations\n\nusing DifferentialEquations\n\nFollowing Box 2.6 from the book, we can derive a differential equation by finding the change in \\(n\\) over the time period \\(\\Delta t\\) in the limit as \\(\\Delta\\) goes to zero. First, we express the dynamics explicitly including \\(\\Delta t\\), the time change over a single time-step.\n\n@variables  Œît\nn‚Ä≤ = n‚Çú*(1+b*Œît)\nn‚Ä≤‚Ä≤ = n‚Ä≤*(1-d*Œît)\nn‚Ä≤‚Ä≤‚Ä≤ = n‚Ä≤‚Ä≤+m*Œît\n\n\\[ \\begin{equation}\nm {\\Delta}t + n_t \\left( 1 + b {\\Delta}t \\right) \\left( 1 - d {\\Delta}t \\right)\n\\end{equation}\n\\]\n\n\nThen we use the definition of a derivative (equation 2.6.2 from the book) to convert the recursion into a differential equation\n\\[\n\\frac{dn(t)}{dt} \\equiv \\text{lim}_{\\Delta t \\rightarrow 0}\\left[\\frac{n(t + \\Delta t) - n(t)}{\\Delta t} \\right]\n\\]\n\neq = (n‚Ä≤‚Ä≤‚Ä≤ - n‚Çú)/Œît \n\n\\[ \\begin{equation}\n\\frac{ - n_t + m {\\Delta}t + n_t \\left( 1 + b {\\Delta}t \\right) \\left( 1 - d {\\Delta}t \\right)}{{\\Delta}t}\n\\end{equation}\n\\]\n\n\n\nsimp_eq = simplify(eq)\n\n\\[ \\begin{equation}\nm + b n_t - d n_t - b d n_t {\\Delta}t\n\\end{equation}\n\\]\n\n\nAfter simplifying, there re no divisions by \\(\\Delta t\\). So we can proceed by setting \\(\\Delta t = 0\\).\n\ndiff_eq = substitute(simp_eq, Œît =&gt; 0)\n\n\\[ \\begin{equation}\nm + b n_t - d n_t\n\\end{equation}\n\\]\n\n\nAgain, we will build a numerical function from the symbolic expression.\n\ndiff_eq_func = eval(build_function(diff_eq, b, d, m, n‚Çú))\n\n\nDifferential Equations from Numerical Functions\nUsing the DifferentialEquations package, we set up an ODE function which accepts 4 arguments for which the canonical names are du (a vector, containing the current trajectories of all variables), u ( the current values of all variables), p (the parameters), t (the current time). I will tend to use capital P in place of p, since we often use a lower-case p for frequency based variables.  Within the body of the function, we assign new values to each element in du according to our governing equations. Here, since we already have a function diff_eq_func which determines the dynamics of the mouse population, I will just use that directly within the ODE function. To pass in the parameter values we will use the ... ‚Äúsplat‚Äù notation, which passes in each element of P as an individua argument, rather than as a single vector of parameters.Specifically, this is the in-place functional form f(du, u, p, t) as opposed to *out-of-place f(u, p, t). In the latter case f would return du rather than modify it.\n\nfunction mice(du, u, P, t)\n    du[1] = diff_eq_func(P..., u[1])\nend\n\nSo in order to solve the ODE we need to create an ODEProblem for our given function, starting values for variables (u0), time span, and parameter values.\n\nu‚ÇÄ = [0.0]\nt_span = (0.0,100.0)\nP = [0.4, 0.5, 1.5]\nprob = ODEProblem(mice, u‚ÇÄ, t_span, P)\n\n\nODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100.0)\nu0: 1-element Vector{Float64}:\n 0.0\n\n\n\nThere is a plotting recipe for differential equation solutions provided by the the popular plotting package Plots, which allows you to get a plot by calling plot(sol). Here we will use Makie and build the plot ‚Äúmanually‚Äù by extracting the time t and dependent variable values u from the solution object.\n\nsol = solve(prob)\ndiff_plt = lines!(ax, sol.t,vcat(sol.u...))\nLegend(fig[1, 2],\n    [rec_plt, rec_plt],\n    [L\"n(t+1)\", L\"\\frac{dn}{dt}\"])\nfig\n\n\n\n\n\n\nDifferential Equations from Symbolic Expressions\n\nusing ModelingToolkit\n\nAnther approach to working with differential equation models in Julia is using ModelingToolkit which mixes symbolic and numeric computing by allowing the user to specify a high-level description of their model, which is then manipulated to produce optimised simulation code. Up till now we‚Äôve just been referring to all symbols as variables but in order to work with ModellingToolkit we will need to be more precise in our terminology, separating variables from parameters and explicitly defining \\(n\\) as a function of \\(t\\). We will also use the syntax D = Differential(t) to set up derivatives(s) w.r.t \\(t\\)\n\n@variables t n(t)\n@parameters b d m Œît\nD = Differential(t)\n\nThen we use identical code to that above, to get to diff_eq\n\nn‚Ä≤ = n*(1+b*Œît)\nn‚Ä≤‚Ä≤ = n‚Ä≤*(1-d*Œît)\nn‚Ä≤‚Ä≤‚Ä≤ = n‚Ä≤‚Ä≤+m*Œît\neq = (n‚Ä≤‚Ä≤‚Ä≤ - n)/Œît\nsimp_eq = simplify(eq)\ndiff_eq = substitute(simp_eq, Œît =&gt; 0)\n\n\\[ \\begin{equation}\nm + b n\\left( t \\right) - d n\\left( t \\right)\n\\end{equation}\n\\]\n\n\nThe nice thing here, is that even though we use n not n(t) in our code, Symbolics remembers that \\(n\\) is a function of \\(t\\).\nRemember D = Differential(t), thus we can use D(n) when setting up a differential equation for the dependent variable \\(n\\) w.r.t. the independent variable \\(t\\).\n\n@named mice_mtk = ODESystem(D(n) ~ diff_eq)\n\n\\[ \\begin{align}\n\\frac{\\mathrm{d} n\\left( t \\right)}{\\mathrm{d}t} =& m + b n\\left( t \\right) - d n\\left( t \\right)\n\\end{align}\n\\]\n\n\nNote the name ODESystem. Here we have a single differential equation, but we could equally have supplied a vector of equations. Likewise, we could have written the equation explicitly D(n) ~ m + b*n - d*n. Another difference between the ModelingToolkit and DifferentialEquations workflow is that we will now be specifying parameter values and initial values for variables as vectors of Pairs where each symbol is assigned a numerical value.\n\nu‚ÇÄ = [n =&gt; 0.0]\nt_span = (0.0,100.0)\nP = [b =&gt; 0.4, d =&gt; 0.5, m  =&gt; 1.5]\nprob_mtk = ODEProblem(mice_mtk, u‚ÇÄ, t_span, P)\n\n\nODEProblem with uType Vector{Float64} and tType Float64. In-place: true\ntimespan: (0.0, 100.0)\nu0: 1-element Vector{Float64}:\n 0.0\n\n\n\nAs a final note, the ModelingToolkit version is a bit faster‚Ä¶\n\nusing BenchmarkTools\n@btime solve(prob);\n\n  66.400 Œºs (976 allocations: 31.92 KiB)\n\n\n\n@btime solve(prob_mtk);\n\n  36.400 Œºs (273 allocations: 25.28 KiB)"
  },
  {
    "objectID": "otto_day/otto_day_04.html",
    "href": "otto_day/otto_day_04.html",
    "title": "4. Numerical and Graphical Techniques",
    "section": "",
    "text": "#using  GLMakie\nŒ± = 2/3#1.1 \nŒ≤ = 4/3#0.4\nŒ¥ = 1#0.5\nŒ≥ = 1#0.4\nLV(n ::Point2,Œ≤) = Point2f(Œ±*n[1] - Œ≤*n[1]*n[2], Œ¥*n[1]*n[2]- Œ≥*n[2])\nLV(n1 ,n2) = Point2f(Œ±*n1 - Œ≤*n1*n2, Œ¥*n1*n2- Œ≥*n2)\nLV(n,p,t) = [Œ±*n[1] - p[1]*n[1]*n[2], Œ¥*n[1]*n[2]- Œ≥*n[2]]\n\n# Create a vector 'z' which is the return value from calling\n# get_z() on the slider value\n\nCR(n, Œ∏ = 1000, c = 0.01, a = 1, œµ = 0.0005, Œ¥ = 0.001) = Point2f((Œ∏ - a*c*n[1]*n[2])/3, (œµ*a*c*n[1]*n[2] - Œ¥*n[2])/3)\nxs = 00:500:20000\nys = 0:2:60\npoints = [Point2f(x,y) for x in xs for y in ys]\ndirections = CR.(points)\n arrows(points,directions)\n\nnull1(x) = 1000/(0.01*x)\nlines!(xs,null1.(xs))\n\nnull2 = 0.001/(0.0005*0.01)\nvlines!(null2)\ncurrent_figure()\n\n\n  \n    \n  \n  \n  \n  \n  \n  \n  \n\n\n\n\nstreamplot(LV,0.0..4.0,0.0..4.0, arrow_size = 15)\n\n\n  \n    \n  \n  \n  \n  \n\n\n\nusing DifferentialEquations\n\nfunction traj(beta)\n  prob = ODEProblem(LV,[2,2],(0,100),[beta] )\n  hcat(solve(prob, saveat = 0.1).u...)'\nend\n\n\nys1 = Observable(rand(20))\nys2 = Observable(rand(20))\nsf = Observable( Base.Fix2(LV,4.0/3.0))\n\nfig = Figure()\nax = Axis(fig[1,1])\nax2 = Axis(fig[1,2])\nax2.limits =(0, 1000, 0, 12)\nax2.xticks = (0:100:1000,string.(collect(0:100:1000) ./10))\nsp = streamplot!(\n        ax,\n        sf,\n        0..3, 0..6;\n        linewidth = 2,\n        arrow_size = 15,\n        colormap =:magma\n    )\n    lines!(ax2, ys1)\n    lines!(ax2, ys2)\n\ni_slider = Slider(fig[2,1],range = 0.5:0.01:6.0)\nlift(i_slider.value) do i\n  sf[]=   Base.Fix2(LV,i)\n  y = traj(i)\n  ys1[] = y[:,1]\n  ys2[] = y[:,2]\nend\n\nusing DifferentialEquations\nfunction traj(beta)\n  prob = ODEProblem(LV,[2,2],(0,100),[beta] )\n  hcat(solve(prob, saveat = 0.1).u...)'\nend\n\n\n\nApp() do session::Session\nys1 = Observable(rand(20))\nys2 = Observable(rand(20))\nsf = Observable( Base.Fix2(LV,4.0/3.0))\n\nfig = Figure()\nax = Axis(fig[1,1])\nax2 = Axis(fig[1,2:3])\nax.limits =(0, 3, 0, 6)\nax2.limits =(0, 1000, 0, 12)\nax2.xticks = (0:100:1000,string.(collect(0:100:1000) ./10))\n\nsp = streamplot!(\n        ax,\n        sf,\n        0..3, 0..6;\n        linewidth = 2,\n        arrow_size = 15,\n        #color =:black,\n        colorrange = (-50,50)\n    )\n    \n    lines!(ax2, ys1, label = \"Prey\")\n    lines!(ax2, ys2, label = \"Predator\")\n    fig[2, 4] = Legend(fig, ax2, \"Trajectories\", framevisible = false)\n\ni_slider = Slider(0.5:0.5:6.0)\nlift(i_slider.value) do i\n  sf[]=   Base.Fix2(LV,i)\n  y = traj(i)\n  ys1[] = y[:,1]\n  ys2[] = y[:,2]\nend\nslider = DOM.div(\"Œ≤: \", i_slider, i_slider.value)\n  return JSServe.record_states(session, DOM.div(slider, fig))\nend\n\n\n  \n    Œ≤: \n      \n      0.5"
  },
  {
    "objectID": "socialevo/problems-1.html",
    "href": "socialevo/problems-1.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "+++ weave = true +++ @def title = ‚ÄúSocial evo probs 1‚Äù\ninsert_weave _assets/problems-1.jmd"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Arthur Newbury",
    "section": "",
    "text": "I am a biosciences PhD candidate in the Angus Buckling lab at University of Exeter, currently working on microbial community assembly and the formation and maintenance of bacteria-plasmid networks."
  },
  {
    "objectID": "index.html#publications",
    "href": "index.html#publications",
    "title": "Arthur Newbury",
    "section": "Publications",
    "text": "Publications\n\n\nCastledine, Meaghan, Arthur Newbury, Rai Lewis, Christian Hacker, Sean Meaden, and Angus Buckling. 2023. ‚ÄúAntagonistic Mobile Genetic Elements Can Counteract Each Other‚Äôs Effects on Microbial Community Composition.‚Äù Mbio 14 (2): e00460‚Äì23.\n\n\nNewbury, Arthur, Beth Dawson, Uli Kl√ºmper, Elze Hesse, Meaghan Castledine, Colin Fontaine, Angus Buckling, and Dirk Sanders. 2022. ‚ÄúFitness Effects of Plasmids Shape the Structure of Bacteria‚ÄìPlasmid Interaction Networks.‚Äù Proceedings of the National Academy of Sciences 119 (22): e2118361119.\n\n\nNewbury, Arthur, Bram Kuijper, and Angus Buckling. 2023. ‚ÄúSpatial Structure Drives Compositional Convergence Between Nutrient Environments in Microbial Communities.‚Äù"
  }
]